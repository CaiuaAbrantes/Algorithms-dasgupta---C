#include <stdio.h>

#define N 6
#define INF 1000

/* Mapeamento simbólico dos vértices */
#define A 1
#define B 2
#define C 3
#define D 4
#define E 5

/* Retorna o menor entre dois valores */
int min(int a, int b) {
    return (a <= b) ? a : b;
}

int main() {

    /*
     * dist[k][i][j] representa a menor distância entre i e j
     * usando apenas os vértices {1, 2, ..., k} como intermediários
     */
    int dist[N][N][N];

    /*
     * Matriz de adjacência do grafo
     * 0 significa ausência de aresta
     */
    int L[5][5] = {
        {0, 2, 1, 0, 0}, // A
        {2, 0, 1, 2, 3}, // B
        {2, 1, 0, 1, 3}, // C
        {4, 2, 2, 0, 4}, // D
        {4, 3, 3, 4, 0}  // E
    };

    /* Inicializa toda a matriz de distâncias */
    for (int k = 0; k < N; k++) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                dist[k][i][j] = 0;
            }
        }
    }

    /*
     * Caso base:
     * dist[0][i][j] = infinito (nenhum intermediário permitido)
     */
    for (int i = 1; i <= 5; i++) {
        for (int j = 1; j <= 5; j++) {
            dist[0][i][j] = INF;
        }
    }

    /*
     * Inicializa distâncias diretas a partir da matriz L
     */
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            if (L[i][j] != 0) {
                dist[0][i + 1][j + 1] = L[i][j];
            }
        }
    }

    /*
     * Algoritmo de Floyd-Warshall
     * Considera progressivamente cada vértice k como intermediário
     */
    for (int k = 1; k <= 5; k++) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 1; j <= 5; j++) {
                dist[k][i][j] = min(
                    dist[k - 1][i][j],
                    dist[k - 1][i][k] + dist[k - 1][k][j]
                );
            }
        }
    }

    /* Imprime a menor distância entre A e D */
    printf("Menor distancia entre A e D: %d\n", dist[5][A][D]);

    return 0;
}
